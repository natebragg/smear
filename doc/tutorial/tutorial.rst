=================
Turnstile Example
=================

.. contents::

.. sectnum::

.. raw:: pdf

         PageBreak oneColumn
   
Simple Turnstile
================

In this tutorial, we'll be creating a simple turnstile program. It
will accept coin events, unlock itself, let a person walk through, and
lock itself. Here's a nice drawing of the basic state machine:

.. figure:: 00_initial.png
    :width: 300

The source for this state machine, reproduced below, is available in
**00_initial.smudge**. You can see the essential elements of a smudge state
machine. The word ``turnstile`` is the name of the state machine. The
part inside the curly braces after the state machine's name is its
definition.

::

    turnstile
    {
       *locked // The * means it's the initial state.
        [
            coin --> unlocked
        ],
    
        unlocked
        [
            person --> locked
        ]
    }

Inside the state machine's definition, there are one or more states
separated by commas. The turnstile example has 2 states called
*locked* and *unlocked*. The initial state will be *locked* for this
state machine.

Each state has the events it can handle (also comma separated)
listed as transitions. A transition is, syntactically, an event name
followed by an arrow followed by a state name. The event causes the
state machine to go to the named state. In this example, the events
are *coin* and *person*. Note that not every event is handled by
every state. Smudge will generate an error if *coin* is sent to a
*turnstile* that's *unlocked*.

Generate Stubs
--------------

So now that we have some Smudge code, let's try building it and making
a program that works. First, make sure Smudge is somewhere in your
path. Then run Smudge on the example.

::

   smudge 00_initial.smudge

This will generate some dot output (the picture above, see sidebar on
the next page), a C file and a pair of headers. They all get dropped
in the same directory as the **.smudge** file.

.. sidebar:: Install GraphViz

    Make sure to install GraphViz to generate this diagram; if
    GraphViz is missing, Smudge will not generate this dot output,
    and will exit with an error, so make sure to install it.

.. sidebar:: Smear and Porting

    By itself, Smudge generates code that's very system-agnostic, so
    it needs some help to send events around, allocate and free
    memory, and handle errors. If you're running on a reasonably
    posix-looking system with support for ``pthreads`` and ``malloc``,
    then you can use Smear's implementation of these things. If your
    ultimate goal is to get Smudge running on a bare-bones embedded
    system with its own (or maybe with no) queue and threading
    implementation, then once you've learned Smudge in the tutorial
    you can move on to the porting guide.

.. sidebar:: On Round-Trips

    There are other code generation systems that support a thing
    called round-tripping. That's where you take the file generated by
    the tool, edit it, then those edits get incorporated into the
    tool's sources. In a round-tripped system, you can generate some
    code, tweak the generated code, then tweak the source for the
    generator and regenerate the code. The generated code will include
    both sets of tweaks.

    Smudge does not support round-tripping. There are currently no
    plans for Smudge to support round-tripping. Smudge's authors don't
    like the idea of editing the generated code, so Smudge is likely
    to never support round-tripping.

There's a little bit more work to do to get a fully functional
program. Smudge doesn't generate a ``main`` function for your program,
so you'll have to write your own. Let's put it in **00_initial_main.c**.

::
   
    /* 00_initial_main.c */

     1  #include <smear.h>
     2  #include "00_initial.h"
     3  #include "00_initial_ext.h"
     4
     5  SRT_HANDLERS(turnstile)
     6
     7  int main(void)
     8  {
     9      SRT_init();
    10      SRT_run();
    11      SRT_wait_for_idle();
    12      SRT_stop();
    13      return 0;
    14  }

Given all these files: the generated **00_initial.h**,
**00_initial.c**, **00_initial_ext.h**, and the above
**00_initial_main.c**, as well as the Smear runtime library
**libsmear.a** and its interface **smear.h**, we can now compile and
link an executable that won't do anything. The Makefile that
accompanies this tutorial has the complete build command.

::

   $ make 00_initial
   /usr/bin/smudge --dot-fmt=Png 00_initial.smudge
   Wrote file "00_initial.png"
   Wrote file "00_initial.h"
   Wrote file "00_initial.c"
   Wrote file "00_initial_ext.h"
   gcc -Wall -Werror -Wextra -Wno-unused-parameter -ggdb3 -L/home/nathan/smear \
   -I/home/nathan/smear/include -o 00_initial 00_initial_main.c 00_initial.c   \
   -lsmear -pthread
   $ ./00_initial

Hooray, it runs and does nothing! Before we start sending events,
let's briefly go over what all that stuff was for. First,
**00_initial_main.c**. **smear.h** defines the runtime's interface,
which is all the functions and macros that begin with
``SRT``. **00_initial.h** and **00_initial_ext.h** define the state
machine's interface. **00_initial_ext.h** has some prototypes that get
implemented by smear and **00_initial.h** will define the interface
for interacting with our state machine.

On line 5, the call to ``SRT_HANDLERS`` does some magic that we don't
have to worry about yet. Just be sure that you invoke it once for each
state machine you have at the top level of a file that includes your
smudge file's **_ext.h** header. Since **00_initial.smudge** only has
one state machine (we'll see how to add more later) named *turnstile*,
we have line 5 as it is.

Moving on, in ``main()``, we see a call to ``SRT_init()``. This call
initializes the runtime, and must come before any functions that send
events. On line 10, there's the ``SRT_run()`` call. This actually
starts execution of the runtime environment. Once ``SRT_run()`` has
been called, your state machines are running.

Line 11 executes Smudge code until there's nothing to do. Since we
haven't sent any events, there's nothing to do right away. We'll add
events for it to process next. ``SRT_stop()`` on line 12 terminates
the runtime and cleans up any memory it had. This is important to do,
as the runtime can hold operating system resources that aren't freed
when your process exits.

Next, that compile command line. You should recognize the **smudge**
command; this just tells it to generate the png-formatted diagram you
see above. The **gcc** command line options include lots of normal
stuff for warnings and debugging. Note that ``-Wno-unused-parameter``
is necessary for a lot of Smudge-generated code, since the code
generator is a little on the lazy side. In large projects, you can
limit your use of that particular flag to just the one .o file that
comes from Smudge. The link path points to the directory with
**libsmear.a** on my system, and the include path points to
**smear.h**. Finally, link with Smear, the runtime environment, and
pthreads (because Smear uses pthreads).

Events
------

Now that we've got something that builds, let's have it actually do stuff.

We can send the *coin* and *person* events by calling the appropriate
event functions from the generated **.h** file. The functions take
pointer arguments which we'll leave NULL for now. The **01_events.c**
and associated **01_events_main.smudge** example files show this.

::

    /* 01_events_main.c */
     1  #include <stdio.h>
     2  #include <smear.h>
     3  #include "01_events.h"
     4  #include "01_events_ext.h"
     5
     6  SRT_HANDLERS(turnstile)
     7
     8  int main(void)
     9  {
    10      SRT_init();
    11      turnstile_coin(NULL);
    12
    13      printf("Initial state: %s\n", turnstile_Current_state_name());
    14
    15      SRT_run();
    16
    17      SRT_wait_for_idle();
    18      printf("State after coin: %s\n", turnstile_Current_state_name());
    19
    20      turnstile_person(NULL);
    21
    22      SRT_wait_for_idle();
    23      printf("State after person: %s\n", turnstile_Current_state_name());
    24
    25      SRT_stop();
    26      return 0;
    27  }

::
    $ ./01_events 
    Initial state: locked
    State after coin: unlocked
    State after person: locked

As you can see, the ``turnstile_person()`` and ``turnstile_coin()``
functions from **01_events.h** send events to the state machine. As
you can see from line 13, no events are processed before ``SRT_run()``
is called. The ``SRT_wait_for_idle()`` calls ensure that events sent
before them are processed by the time they return. Try replacing one
of the ``SRT_wait_for_idle()`` calls with a ``sleep(0)`` and run the
resulting program several times. Smudge runs events in a separate
thread, so progress can be nondeterministic.


.. sidebar:: Debugging Functions

    The **events.c** example uses ``turnstile_Current_state_name`` to
    demonstrate that the state machine is transitioning states. The
    ``_Current_state_name`` function is generated for every state
    machine, and will return a string with the name of the appropriate
    machine's current state. Its prototype is generated in the smudge
    module's **.h** file.

    In addition to this ``Current_state_name`` function that's
    generated for every state machine, Smudge uses the
    ``SMUDGE_panic_print`` function to indicate that a state machine
    has been sent an event that's unhandled in its current state. You
    can write whatever you want in the body of ``SMUDGE_panic_print``,
    but the three arguments can be passed straight to ``printf`` in
    order to generate a sensible error message.

    These functions require Smudge to generate a significant number of
    constant strings, which on some platforms will overtax limited
    resources. Since Smudge is designed for use on embedded systems,
    there's a way to turn these off. If you pass ``--c-no-debug`` to
    Smudge on the command line, the ``_Current_state_name`` functions
    will return empty strings (a single null character) and
    ``SMUDGE_panic_print`` will never be called. Instead, Smudge will
    call ``SMUDGE_panic`` when an unhandled event is received by a
    state machine. This function takes no arguments and can do
    whatever things ``SMUDGE_panic_print`` does that don't require
    knowledge of the current state and the event that triggered the
    error. This is a good place to put debugger traps.

Do Something
------------

So far, we have a state machine that can transition states, but it
doesn't do anything. For that, we need side effects. There are two
types of side effects in Smudge: C functions that are called directly
(@functions) and events. For now, we'll focus on @functions. The name
of an @function can be any valid C identifier for reasons that will
become apparent soon.

When a person walks through an unlocked turnstile, we'd like it to
play a sound. When a coin is inserted, it should flash some LEDs. To
add these features to our turnstile state machine, see
**side_effects.smudge**.

::

    turnstile
    {
       *locked // The * means it's the initial state.
        [
            coin -(@flashLEDs)-> unlocked
        ],
    
        unlocked
        [
            person -(@soundOkay)-> locked
        ]
    }

Note that the arrows have changed from ``-->`` to ``-(@function)->``. This is
a more general arrow. The full arrow syntax is ``-(`` followed by a
comma separated list of side effects (@functions and events) followed
by ``)->``. The ``-->`` syntax we've been using is shorthand for
``-()->``.

Now run Smudge again and look at **side_effects_ext.h**. Note that in
addition to the prototypes from **initial.smudge**, there are
prototypes for ``flashLEDs`` and ``soundOkay``. These functions have
to be added to main.c. Running Smudge with ``--c-stubs`` on
**initial.smudge** will generate stubs for these functions, too.

.. figure:: side_effects.png
    :width: 500

A simple program that implements these functions is in
**use_side_effects.c**. You can run it and see the side effects being
triggered.

Event Payloads
==============

You may have noticed that these side effect functions take pointers to
arguments whose types are left incomplete in
**side_effects.h**. Smudge won't ever put anything in these payloads,
but you can. Let's say that you want to pay attention to who's going
through your turnstile and play a nice customized greeting for them
when they pass. **payloads.c** uses the same **side_effects.smudge**
file, but adds some code to do just that.


.. raw:: pdf

         PageBreak oneColumn

Message Passing
===============

Before we go any further, it's time to talk about Smudge's message
passing mechanism. Smudge expects events it passes to the user through
``_Send_Message`` to be passed back to it through the corresponding
``_Handle_Message``. It expects order to be maintained, but they don't
have to be passed right back immediately. In fact, for nontrivial
state machines, it's bad to call ``_Handle_Message`` from within
``_Send_Message``.

The intent of these functions is for the system to queue up the
messages then hand them back when it's convenient. This lets the state
machine accept events from multiple threads, reduces the maximum stack
depth, and lets events be handled sanely even if their event handlers
send events.

The example code in **message_passing.c** uses a simple queue as a
proxy for the system's message queue. It implements a slightly more
realistic turnstile_Send_Message, and another loop that runs through
the queue and calls ``turnstile_Handle_Message`` and
``turnstile_Free_Message``.

Dynamic Allocation
------------------

You can compile **message_passing**, and depending on your system you
may even be able to run it. However, it has a fatal flaw:

::

   $ ./message_passing 
   turnstile[locked]: Unhandled event "person"
   Blinky blinky
   Segmentation fault: 11

Smudge passes an event wrapper in to ``turnstile_Send_Message`` by
value, but the ``turnstile_person`` function takes a pointer to an
event. In **message_passing.c**, that pointer was to values that lived
on the stack. Once that stack frame was gone, accessing those pointers
resulted in undefined behavior. Usually, though, it'll cause a
segfault.

The way around this, clearly, is to allocate those events on the heap
instead of using the stack. The next file, **dynamic_payloads.c**,
shows how Smudge handles dynamic memory allocation for event
payloads. After the event wrapper is passed to
``turnstile_Handle_Message``, it should be given to
``turnstile_Free_Message``. That function will, in turn, call
``SMUDGE_free``. As you can see if you run **dynamic_payloads**, the
pointers passed to ``SMUDGE_free`` are the same as those passed to
``turnstile_coin`` and ``turnstile_person``.

::

   $ make dynamic_payloads
   stack exec smudge -- --dot-fmt=Svg side_effects.smudge
   Wrote file "side_effects.svg"
   Wrote file "side_effects.h"
   Wrote file "side_effects.c"
   Wrote file "side_effects_ext.h"
   gcc -c -o side_effects.o -Wall -Wextra -Wno-unused-parameter side_effects.c
   gcc -c -o dynamic_payloads.o -Wall -Wextra -Wno-unused-parameter
   dynamic_payloads.c
   gcc -c -o queue.o -Wall -Wextra -Wno-unused-parameter queue.c
   gcc -o dynamic_payloads -Wall -Wextra -Wno-unused-parameter side_effects.o
   dynamic_payloads.o queue.o
   rm side_effects.c

   $ ./dynamic_payloads 
   Sending person event Thomas at 0x7f8b86c02760.
   Sending person event Nikola at 0x7f8b86c02750.
   turnstile[locked]: Unhandled event "person"
   Freeing Thomas at 0x7f8b86c02760
   Blinky blinky
   Welcome to the other side of the turnstile, Nikola.
   Freeing Nikola at 0x7f8b86c02750

Note that all events are passed to the same ``SMUDGE_free``
function. It should be able to handle any event sent to any state
machine. That almost certainly means ``NULL`` pointers, and if events
are ever allocated through methods other than ``malloc`` they will have
to be handled properly.

.. raw:: pdf

         PageBreak oneColumn

Wrapping Up
-----------

Memory management is tricky in C. If your program allocates memory for
a message wrapper, it has to free it after calling the appropriate
state machine's ``_Free_Message`` function to free the event
itself. If this seems confusing, you might want to spend some time
with the example (including the generated C code) until you understand
it.

The message passing scheme is one of the more complicated concepts to
understand in Smudge. Events get sent by user code with calls like
``turnstile_person(e)``. Then Smudge packages them up and hands them
right back to the user code in the form of a
``turnstile_Event_Wrapper_t`` passed to
``turnstile_Send_Message``. The events are sent as pointers, but the
wrappers come in by value. What the user code does next affects
Smudge's semantics.

If the user code behaves like the example in **dynamic_payloads.c**,
Smudge will have the semantics we use in this document. Events are
handled in order but not immediately. If an event is sent as a side
effect of another event, it will be handled after any state transition
caused by the original event.

If, instead, the ``turnstile_Send_Message`` function just calls
``turnstile_Handle_Message`` directly, like in **use_side_effects.c**,
that behavior changes. For simple state machines like
**side_effects.smudge**, this distinction probably doesn't
matter. However, for complex state machines you might use in
production code, this can cause some very weird bugs. It also tends to
increase your maximum stack depth, which can become a problem on
embedded systems.

Nonetheless, you define this aspect of Smudge's semantics. If you want
to make up a new data structure where the order of elements being
removed from it is not deterministic, then your events won't be
handled in a deterministic order.

Smudge does guarantee that @functions will always be handled right
away in the order in which they're called. That means that ``event
-(@a, otherEvent, @b)-> STATE`` will, with the behavior we're using in
dynamic_payloads.c, call ``a`` then ``b``, then handle *otherEvent*
from with in the state *STATE*.

Enter/Exit Functions
====================

Now our turnstile can accept a coin and allow a person through. It
doesn't actually lock or unlock though. To do that, we need to call
side effect functions when we enter the locked and unlocked
states. Between the name of a state machine and the ``[``, there is an
optional list of side effects surrounded by parentheses. These can be
@functions or events just like in arrows. Likewise, there's an
optional parenthesized list of @functions after the ``]``. The first list
is called immediately when the state is entered. The second list is
called after the state exits but before any other state is entered.

.. figure:: enter_exit.png
    :width: 500

Like with other lists of side effects, these functions are always
called in the order in which they're listed.

Unlike event side effects, @functions used on state enter and exit
don't accept any arguments. If you use the same function as an
enter/exit function and an event side effect, the generated prototype
for the function will accept no arguments and the event won't be
passed to the side effect function.

.. sidebar:: Side Effect Function Arguments

    All of the @functions we've looked at so far have taken a single
    event as an argument. State enter/exit functions take no
    arguments, since there's no associated event. This leads to a
    problem if you want to use the same function in both contexts. A
    similar problem arises when the same @function is called as the
    result of two different events.

    When Smudge detects this kind of inconsistency in the use of an
    @function, it decides that you weren't going to use the argument
    anyway and gets rid of it.

The files **enter_exit.smudge** and **use_enter_exit.c** add
lockedEnter and lockedExit as well as unlockedEnter to the state
machine. Now the turnstile can actually lock and unlock itself instead
of just waving as people go through. In the interest of simplicity,
we're going to put all that message passing stuff from the previous
chapter on the shelf. It will show up again later, but for now it's
mostly clutter.

Transitionless Events
=====================

Our turnstile is starting to look pretty nice, but what if a person
tries to go through it without paying? It would be good to have an
event that's handled by a state, but that doesn't cause a state
transition. We could put ``person --> locked`` in the locked state,
but that would cause it to exit and re-enter locked just because a
person tried to jump through. Since we don't want ``lockedEnter`` or
``lockedExit`` called, we need to use a different kind of event handler.

In addition to the arrow syntax, Smudge supports dash syntax to handle
an event without a state transition. A dash is just an arrow without a
``>`` character or a destination state. It looks like ``-(<side effect
list>)-``. Like with arrows, if the side effect list is empty you can
omit the parentheses.

.. figure:: transitionless.png
    :width: 700

The next example, **transitionless.smudge** and associated
**use_transitionless.c**, adds a second event handler (note the comma)
to the locked state and a new @function called ``soundAlarm``.

Transient States
================

Great, now our turnstile shames people who try to get through without
paying. Let's add a little state to power it up. Instead of starting
in locked, it should light up all its LEDs in a test pattern then go
straight to locked. This new state is called a transient state because
it doesn't stay around long enough to ever get any events.

.. figure:: transient.png
   :width: 700

The **transient.smudge** and **use_transient.c** example files add
this little state and a message to indicate that the turnstile is
powering up.

Multiple State Machines
=======================

The turnstile has been running nicely for a few days now, and the
customer (a subway system) is very happy. Wait a second, they say
they've been getting less money than expected and metal slugs are
piling up in the coin bin! That's no good, we need to validate those
coins before accepting them!

Smudge allows multiple state machines to be defined in the same
file. **multisim.c** and **msm.smudge** add a new simple single-state
machine to validate coins and deal with fakes. This is quite a bit of
new code, but the only really new piece of syntax is sending an event
as a side effect to a different state machine.

.. figure:: msm.png
   :width: 100%

The C code is a little more complicated, since we now have 2 different
machines to queue and dispatch messages for. On a real system, each of
these can have its own message queue, or they can share the system's
message queue like in the example.

.. sidebar:: Naming Things

   It is well known that the 2 hardest things in programming are cache
   invalidation, naming things, and off by one errors. Smudge lets you
   name things with a pretty wide character set. Events, states, and
   state machine names can contain characters not found in C
   identifiers like ``My-favorite-state-machine`` or even be quoted
   strings with a big character set like ``"Some (event) or other,
   +/-"``. When Smudge converts these things to C, it has to mangle
   the names into something that fits within the set of valid C
   identifiers.

   The precise way in which Smudge mangles names is not important for
   this tutorial, but there are a few properties that you might want
   to keep in mind. First, you never need to see the mangled names of
   states. If you want to name a state ``"The $%#!@ state"``, you'll be
   able to call ``SM_Current_state_name()`` and get that string back.

   However, for the names of your state machines, the mangling
   matters. If you use a state machine name that begins with a number,
   Smudge will generate an invalid identifier and it won't compile. If
   you use any other character but a letter to begin the name of your
   state machine, Smudge will mangle its name into something that
   begins with an underscore. Since the C standard reserves most
   symbols beginning with underscores, this could lead to undefined
   behavior. Use names for your state machines that begin with
   letters.

Syntactic Shortcuts
===================

You can use what you know now to generate anything Smudge can
generate. These next two sections cover some syntactic sugar that
Smudge provides to make your state machines more maintainable.

Default States
--------------

What if we want to handle a particular event the same regardless of
the current state? If someone shakes the turnstile, it should give off
a warning regardless of the current state of the machine. We could put
``tilt -(@soundAlarm)-`` in every state, but that's error prone and
nightmarish to maintain. Instead, there's a special state called the
*any-state*. Its name is a single underscore (``_``). If an event is
not specified in the current state, but it is specified in the
any-state, it will be handled according to its handler in the
any-state. An event that's specified in both will be handled by the
current state's handler.

.. figure:: default_states.png
   :width: 100%

The files **default_states.smudge** and **any_state.c** show some
extra code to handle tilting. Note that the ``soundAlarm`` @function has
had its signature changed because it's called in two incompatible
contexts. In this example, tilting the machine will cause it to eat
any money that's been inserted. They probably deserve it.

Default Events
--------------

Up until now, an unhandled event will cause the state machine to quit
with an error. That's not very friendly. If we have a state where we
don't want to crash on events that aren't handled explicitly, but want
to take the same action on all of them, we can use the *any-event*.

Since the *any-event* and *any-state* both cause default behavior,
there's a defined precedence order. Named events in named states are
always handled. If that doesn't exist for a given event/state
combination, named events in the *any-state* are handled next. If an
event is not named in the current or *any* state, it will be handled
by the *any-event* handler in the current state. If there isn't one of
those, it gets handled by an *any-event* handler in the
*any-state*. Here's a handy table with that precedence order. In
general, named things take precedence over unnamed things.

+-------+-------+
| state | event |
+=======+=======+
| named | named |
+-------+-------+
|  any  | named |
+-------+-------+
| named |  any  |
+-------+-------+
|  any  |  any  |
+-------+-------+

Like the any-state, the any-event's name is a single underscore
character. **any_event.c** and **default_events.smudge** show the
any-event in action. Since named event handlers take priority over
any-event handlers, we need to explicitly handle all the events from
the any-state in a state with the any-event.
