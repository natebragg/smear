===============
Pinball Example
===============

.. contents::

.. sectnum::

.. raw:: pdf

         PageBreak oneColumn

Simple Pinball Machine
======================

Welcome to the Smudge tutorial! This is intended for people familiar
with C and the \*nix environment. In particular, it will assume a good
knowledge of the C language, a working understanding of libraries and
linkers, and good facility with the command line. It is assumed that
your environment is Linux and supports pthreads. Other environments
can be made to work, but might require more advanced knowledge.

In this tutorial, we'll create a simple pinball machine game. It will
accept coins from players, drop a ball, then accumulate a score until
the ball is lost through the drain.

.. figure:: 00_pinball.png
   :width: 500

The drawing above shows a state diagram for this simple machine. As
you can see, it starts in the *idle* state. The *coin* event moves it
to *run* and *drain* (when the ball falls through the drain) moves it
back to idle.

The Smudge source code for the above machine is shown below:

.. code-block:: c
   :include: 00_pinball.smudge
   :linenos:

This shows the basic structure of a Smudge state machine. The machine is called
``pinball`` and its states (``idle`` and ``run``)
are listed inside the curly brackets. The ``*`` before ``idle``
indicates that it's the initial state. Events are handled in each
state with an arrow (``-->``) that shows which state will be next when
that event is received. 

Generate Code
-------------

This is a pretty simple pinball machine, but let's see if we can get
it to compile before doing something more complicated. First, we need
a file that has ``main`` in it.

.. code-block:: c
   :include: 00_main.c
   :linenos:

That's about as minimal a C file as we can have and still use
Smudge. We'll talk about what all the lines do later, but for now the
important thing is to have ``SRT_HANDLERS`` called for every state
machine. Since there's only one, and it's called ``pinball``, we have
the above ``SRT_HANDLERS(pinball)``.

Now to build the whole thing into an executable.

::

   $ make 00_pinball
   /usr/bin/smudge --dot-fmt=Png 00_pinball.smudge
   Wrote file "00_pinball.png"
   Wrote file "00_pinball.h"
   Wrote file "00_pinball.c"
   Wrote file "00_pinball_ext.h"
   gcc -Wall -Werror -Wextra -Wno-unused-parameter -ggdb3 \
   -I/home/nathan/smear/include -c -o 00_pinball.o 00_pinball.c
   gcc -Wall -Werror -Wextra -Wno-unused-parameter -ggdb3 \
   -I/home/nathan/smear/include -c -o 00_main.o 00_main.c
   gcc -L/home/nathan/smear -o 00_pinball 00_pinball.o 00_main.o \
   -lsmear -pthread

   $ ./00_pinball

Hooray, it compiles and does nothing! Before we start sending events,
let's briefly go over all those commands and what they do. First, and
most simply, there's

::

   /usr/bin/smudge --dot-fmt=Png 00_pinball.smudge

This just runs Smudge on our source file and tells it to format the
picture with the state diagram as a **.png**. This command generates
several files:

 * 00_pinball.png
 * 00_pinball.h
 * 00_pinball.c
 * 00_pinball_ext.h


The only .c file, **pinball.c**, actually implements the state
machine. Everything else (except the picture) is an
interface. **00_pinball_ext.h** is the interface to the functions
provided by the runtime environment. You don't have to worry about
these, just know that they're provided by ``SRT_HANDLERS`` and
**libsmear.a**. **00_pinball.h** is the interface to your state
machine. It has prototypes for functions generated by Smudge.  We'll
see how to use these functions in the next section.

::
   
   gcc -Wall -Werror -Wextra -Wno-unused-parameter -ggdb3 \
   -I/home/nathan/smear/include -c -o 00_pinball.o 00_pinball.c
   gcc -Wall -Werror -Wextra -Wno-unused-parameter -ggdb3 \
   -I/home/nathan/smear/include -c -o 00_main.o 00_main.c
   gcc -L/home/nathan/smear -o 00_pinball 00_pinball.o 00_main.o \
   -lsmear -pthread

The rest of these commands are just compiling the generated
**00_pinball.o**, the tiny **00_main.o**, and linking everything
together along with Smear. You can see that I have **libsmear.a** in
my **/home/nathan/smear** directory, and **smear.h** is in
**/home/nathan/smear/include**. If you have Smear checked out like I
do, you can do the same thing with your link and include paths. If you
installed Smear system-wide, you can leave out those paths.

Events
------

Once the whole thing is built, I run the generated **00_pinball** and
it produces no output. Let's see if we can change it to actually
respond to some events. First, let's switch to example 1 (which has
the same Smudge source as 0) and run Smudge on it.

::

   $ smudge 01_pinball.smudge

It generated the files we saw before (with a different image format
for the diagram). Let's look more closely at **01_pinball.h**.

.. code-block:: c
    :include: 01_pinball.h
    :linenos:
       
The important lines here are 22 and 24, which define the *coin* and
*drain* events from our Smudge file. Don't worry about their arguments
for now; we can just send NULL pointers. Also useful for debugging
(and demonstrating things in tutorials) is the
``pinball_Current_state_name`` function. It returns a string
containing the name of the machine's current state.

Let's write a new **01_main.c** to use these functions.

.. code-block:: c
   :include: 01_main.c
   :linenos:

And when we compile and run this program, we get:

::

   $ ./01_pinball
   Sending coin event.
   Starting runtime.
   Current state: idle
   Waiting until the machine is idle.
   Current state: run
   Sending drain event.
   Current state: run
   Waiting until the machine is idle.
   Current state: idle

Note how the events aren't actually processed until the
``SRT_wait_for_idle()`` call returns. This is because Smudge code runs
in a multithreaded environment. You can send an event from any thread,
but it won't be handled until the operating system switches out that
thread's context and executes the Smudge runtime environment (thus
``SRT``) which receives the events and moves the state machine
forward. You can rely on the operating system to do this for you, or
you can explicitly wait until all the pending events have been
handled. That second option is what the ``SRT_wait_for_idle`` function
does. It acts like a fence in that all events sent before it are
handled before it returns.

Error Handling
--------------

If we add a call to ``pinball_drain(NULL)`` before the last
``SRT_wait_for_idle()`` call in **01_main.c** (on line 33), we get
**02_main.c**.  Since the *drain* event is not handled when the
*pinball* machine is in the *idle* state, this generates an error and
returns early:

::

   $ ./02_pinball 
   Sending coin event.
   Starting runtime.
   Current state: idle
   Waiting until the machine is idle.
   Current state: run
   Sending drain event.
   Current state: run
   Waiting until the machine is idle.
   Current state: idle
   pinball[idle]: Unhandled event "drain"
   $ echo $?
   255

We won't be generating a lot of errors in this tutorial, but it's
important to know how they're handled. Isn't that a nice message? It
tells you the current state and the received event.

Side Effects
============

Our pinball machine looks cool, but it doesn't actually do
anything. All that happens when you send an event is a state
transition, but the only thing we know about different states is that
they can handle different events. Enter side effects, to make your
state machines do stuff.

The first kind of side effect we're going to talk about is called an
``@function``. It is so named because in the Smudge source, it begins
with the ``@`` character, and it calls a C function that you will
write. Let's add a new event to the *run* state to increase the
player's score every time the ball hits a target.

.. code-block:: c
   :include: 03_pinball.smudge
   :linenos:

There are two new things in this example: an ``@function`` called
``incScore``, and the dash. Dashes are just like arrows, except they
don't cause state transitions. I know, you're thinking to yourself
that this new ``-(...)-`` thing is way different, because in addition
to not having a ``>`` at the end, it's got this side effect thing
surrounded by parentheses. Well, it turns out that the syntax for an
arrow is actually ``-(side-effect-list)->`` and that ``-->`` is
shorthand for ``-()->``. Likewise, there's a dash shorthand: ``--`` is
the same as ``-()-``. It gets used less often, though, since it just
silently ignores an event.

Running **smudge** on this new example gives us the expected
**03_pinball...** files. However, if you looked at
**02_pinball_ext.h** and **03_pinball_ext.h**, you'd see a difference:
there's a new function prototype for ``incScore`` in there. If you try
to compile with the same stuff that's in **02_main.c**, you'll se a
linker error. It wants that ``incScore`` function to be defined. Let's
do that.

.. code-block:: c
   :include: 03_main.c
   :linenos:

Running this new program gives us the expected

::

   $ ./03_pinball
   ding ding, new score: 1
   ding ding, new score: 2

So now we can have side effects, that's cool. They also give us a
reason to be in different states, since we can react to the same event
with different side effects depending on which state we're in. There's
another place we can put side effect lists: before we enter a state
and after we leave it. These are called enter/exit functions. Let's
use some to make our pinball machine a little more flashy.

.. code-block:: c
   :include: 04_pinball.smudge
   :linenos:

Here in **04_pinball.smudge**, we've gone nuts with the
``@functions``. The new *prepare-ball* state executes 3 of them when
it's entered. Note that Smudge guarantees that ``@function`` side
effects will be executed in the order they're listed. The *run* state
here demonstrates why *target* doesn't look like ``target
-(@incScore)-> run``. If it did, it would execute the exit-function
then the enter-function for *run*. That may be desirable in some
instances, but it's not in this one.

Let's make a **04_main.c** to go with this. Nothing new here, just a
whole lot of events getting sent and handled.

.. code-block:: c
   :include: 04_main.c
   :linenos:

And when it's built and run:

::

   $ ./04_pinball
     1	Locking paddles.
     2	Dropping ball.
     3	Unlocking paddles. Whirrrrrr
     4	Ding ding ding ding ding
     5	DingDing
     6	Awwwwwww
     7	Score: 2
     8	A new high score!
     9	Locking paddles.
    10	Dropping ball.
    11	Unlocking paddles. Whirrrrrr
    12	Ding ding ding ding ding
    13	DingDingDingDingDingDingDingDingDingDingDing[...]
    14	Awwwwwww
    15	Score: 100
    16	A new high score!
    17	Locking paddles.
    18	Dropping ball.
    19	Unlocking paddles. Whirrrrrr
    20	Ding ding ding ding ding
    21	Ding
    22	Awwwwwww
    23	Score: 1
    24	High score: 100
    25	Locking paddles.

Default Handlers
================

People have started doing bad and unexpected things to our pinball
machine. Someone put two coins in, one after the other and made the
whole thing crash. Other people keep lifting the front of the machine
to artificially boost their scores.

Any-Event
---------

Fortunately for us, there's a tilt sensor in our pinball machine. All
we have to do is hook up the event to our Smudge machine.

.. code-block:: c
   :include: 05_pinball.smudge
   :linenos:

Combined with implementations of ``displayError`` and ``startTimer``
in **05_main.c**, this new *lockout* state ignores all events until
the timer expires.
      
Any-State
---------

Transient States
================

This pinball machine is starting to work pretty well, but it's having
some boot-up problems. There's stuff it wants to do when it powers on
that's not getting done.

To fix this, we're going to introduce a new initial state called
*power-on* that instantly transitions to the *idle* state.

.. code-block:: c
   :include: 05_pinball.smudge
   :linenos:

Transient states take this ``state -(side-effect-list)-> next-state``
form. They don't handle any events, since the state machine
transitions out of a transient state as soon as it's entered.

Multiple Machines
=================

Event Payloads
==============
